From c2e6dbc47d1a1004425d0ea3bd6daf8d2070d2ea Mon Sep 17 00:00:00 2001
From: Minggui Cao <minggui.cao@intel.com>
Date: Fri, 29 Oct 2021 14:45:38 +0800
Subject: [PATCH 1/2] hv: support non-spec CAT ASSOC MSR setting

some platform CAT ASSOC MSR not follow spec, need to support.
to support TGL/EHL/ADL and WHL/CFL

rebase to v2.6

Signed-off-by: Minggui Cao <minggui.cao@intel.com>
---
 hypervisor/arch/x86/guest/vmsr.c | 10 +++-----
 hypervisor/arch/x86/rdt.c        | 39 +++++++++++++++++++++++++++++++-
 2 files changed, 41 insertions(+), 8 deletions(-)

diff --git a/hypervisor/arch/x86/guest/vmsr.c b/hypervisor/arch/x86/guest/vmsr.c
index eb2a81de2..f03663fd7 100644
--- a/hypervisor/arch/x86/guest/vmsr.c
+++ b/hypervisor/arch/x86/guest/vmsr.c
@@ -321,13 +321,9 @@ static void prepare_auto_msr_area (struct acrn_vcpu *vcpu)
 
 	/* only load/restore MSR IA32_PQR_ASSOC when hv and guest have differnt settings */
 	if (is_platform_rdt_capable() && (vcpu_clos != hv_clos)) {
-		vcpu->arch.msr_area.guest[MSR_AREA_IA32_PQR_ASSOC].msr_index = MSR_IA32_PQR_ASSOC;
-		vcpu->arch.msr_area.guest[MSR_AREA_IA32_PQR_ASSOC].value = clos2pqr_msr(vcpu_clos);
-		vcpu->arch.msr_area.host[MSR_AREA_IA32_PQR_ASSOC].msr_index = MSR_IA32_PQR_ASSOC;
-		vcpu->arch.msr_area.host[MSR_AREA_IA32_PQR_ASSOC].value = clos2pqr_msr(hv_clos);
-		vcpu->arch.msr_area.count++;
-		pr_acrnlog("switch clos for VM %u vcpu_id %u, host 0x%x, guest 0x%x",
-			vcpu->vm->vm_id, vcpu->vcpu_id, hv_clos, vcpu_clos);
+		msr_write_pcpu(MSR_IA32_PQR_ASSOC, clos2pqr_msr(vcpu_clos), pcpuid_from_vcpu(vcpu));
+		pr_acrnlog("switch clos for VM %u vcpu_id %u: 0x%x",
+			vcpu->vm->vm_id, vcpu->vcpu_id, vcpu_clos);
 	}
 }
 
diff --git a/hypervisor/arch/x86/rdt.c b/hypervisor/arch/x86/rdt.c
index b3dc54978..6bcf8cbf8 100644
--- a/hypervisor/arch/x86/rdt.c
+++ b/hypervisor/arch/x86/rdt.c
@@ -60,6 +60,35 @@ static struct rdt_info res_cap_info[RDT_NUM_RESOURCES] = {
 	},
 };
 
+static void check_init_L2_cat(void)
+{
+	struct cpuinfo_x86 *cpu_info = get_pcpu_info();
+
+	if ((cpu_info->displayfamily == 6) &&
+		(cpu_info->displaymodel == 0x96 /* EHL */)) {
+
+		res_cap_info[RDT_RESOURCE_L2].clos_max = MAX_CACHE_CLOS_NUM_ENTRIES;
+
+		platform_l2_clos_array[0].value.clos_mask = 0x0ff;
+		platform_l2_clos_array[1].value.clos_mask = 0xf00;
+		platform_l2_clos_array[2].value.clos_mask = 0x00f;
+		platform_l2_clos_array[3].value.clos_mask = 0x001;
+	}
+}
+
+static inline bool is_follow_spec()
+{
+	struct cpuinfo_x86 *cpu_info = get_pcpu_info();
+
+	if (cpu_info->displayfamily == 6 &&
+		((cpu_info->displaymodel == 0x8c /* TGL-U */) ||
+		(cpu_info->displaymodel == 0x96 /* EHL */) ||
+		(cpu_info->displaymodel == 0x97 /* ADL */))) {
+		return true;
+	}
+	return false;
+}
+
 /*
  * @pre res == RDT_RESOURCE_L3 || res == RDT_RESOURCE_L2
  */
@@ -114,7 +143,12 @@ void init_rdt_info(void)
 	uint8_t i;
 	uint32_t eax = 0U, ebx = 0U, ecx = 0U, edx = 0U;
 
-	if (pcpu_has_cap(X86_FEATURE_RDT_A)) {
+	if (MAX_CACHE_CLOS_NUM_ENTRIES > 0) {
+		pr_acrnlog("LLC CAT enabled, %sfollow spec\n", is_follow_spec() ? "" : "not ");
+		res_cap_info[RDT_RESOURCE_L3].clos_max = MAX_CACHE_CLOS_NUM_ENTRIES;
+
+		check_init_L2_cat();
+	} else if (pcpu_has_cap(X86_FEATURE_RDT_A)) {
 		cpuid_subleaf(CPUID_RDT_ALLOCATION, 0U, &eax, &ebx, &ecx, &edx);
 
 		/* If HW supports L3 CAT, EBX[1] is set */
@@ -197,6 +231,9 @@ uint64_t clos2pqr_msr(uint16_t clos)
 {
 	uint64_t pqr_assoc;
 
+	if (!is_follow_spec()) {
+		return clos;
+	}
 	pqr_assoc = msr_read(MSR_IA32_PQR_ASSOC);
 	pqr_assoc = (pqr_assoc & 0xffffffffUL) | ((uint64_t)clos << 32U);
 
-- 
2.17.1

